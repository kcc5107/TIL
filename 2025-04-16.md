# TIL
## Lv1. 계산기 프로그램
### 문제 상황
사칙연산 기호를 잘못 입력하거나, 0으로 나눗셈을 할 경우 ```return;```처리를 했고  
그 결과 프로그램이 종료되어 계산을 반복문으로 넣어서 반복시켰음에도 계산을 진행할 수 없었다.
### 해결 과정
```return;```을 ```break;```로 수정 후 ```if (result != 0)```조건으로 result가 초기화된 값 0이 아닐 경우에만 결과값을 출력하도록 수정하였다.
-> 그러나 빼기, 곱셈, 나눗셈에서 연산 결과가 0이 나올 수 있음을 뒤늦게 인지
### 최종 해결 방법
```return;```대신 ```continue```를 사용하여 이후 코드를 건너뛰고 반복문의 다음 사이클로 넘어가도록 처리하였다.
### 다른 대안
boolean타입으로 true, false 값을 변경하여 정상 계산여부를 체크하는 방향

## Lv2. 클래스를 적용한 계산기 프로그램
### 문제 상황
계산 로직을 **static 메서드**로 구현하고자 했으나, 연산 결과를 컬렉션타입 필드에 저장하려는 과정에서  
**인스턴스 필드** 접근이 필요해 문제가 발생했다.
### 해결 과정
인스턴스 필드로는 접근이 안되기 때문에 필드도 static으로 변경  
이는 컬렉션 필드에 직접 접근하지 못하도록 캡슐화 하는 조건에 반한다고 생각했으나  
private static 필드도 사용 가능하므로, 캡슐화 원칙에 위배되진 않는다.  
-> 하지만 `setResults()`와 같은 세터에서 `this`는 인스턴스 필드를 참조하므로 static에서는 사용 불가
### 최종 해결 방법
계산 로직이 결국 인스턴스 필드에 접근해야하기 때문에 static 메서드보다는  
인스턴스 메서드로 구현하는 것이 적절하다고 판단해 수정하였다.
### 배운점
1. static메서드는 인스턴스 필드에 접근할 수 없기 때문에 인스턴스 필드를 사용하는 로직엔 적합하지 않다.  
2. `this`는 오직 인스턴스 맥락에서만 사용 가능  
3. 캡슐화를 유지하면서 static을 사용할 수 있지만, 설계 관점에서 적절한 방법인지 따져야 한다.