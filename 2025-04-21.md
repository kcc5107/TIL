# TIL

## Lv3. Enum, 제네릭, 람다&스트림을 이해한 계산기 만들기

### Enum 사칙연산 기호 활용 트러블슈팅

## 문제 상황
- `enum.name()`을 사용해서 문자열로 비교하려 했지만, `switch-case`에서  
`String` 비교는 Enum의 타입 안정성과 매칭의 장점이 사라진다.

## 해결 과정
- `checkOperator()` 메서드는 문자열이 아닌 `OperatorType` Enum 객체 자체를 반환하도록 변경하였고  
이후 `switch-case`에서 `OperatorType`을 직접 비교함으로써 Enum의 장점을 유지하면서 코드의 안정성과 가독성을 향상시킬수 있었다.

## 배운점
- `name()`으로 문자열을 비교하는 방식은 일반 문자열 비교와 마찬가지로 Enum을 사용하는 이점(타입 안정성)을 없애고 무의미하다.
- Enum을 제대로 활용하려면 객체 자체로 다루고, `switch`에서도 Enum 상수로 나타내야한다.

--- 
  
### 제네릭 관련 트러블슈팅 

## 문제 상황
- 계산기 메서드에 `<T, T, S>` 형태의 제네릭을 사용해 숫자와 연산 기호 모두를 유연하게 처리하려고 하였다.  
- 하지만 연산 기호를 Enum에서 판별하는 `checkOperator()` 메서드에 넘기려면 `char` 또는 `String` 타입이  
필요했기 때문에 제네릭 타입으로는 Enum과의 비교가 어려웠고 오류가 발생했다.

## 해결 과정
- 연산기호를 제네릭 타입 매개변수로 받은 뒤, `Character`로 형변환하는 방식도 시도했지만 복잡도만 증가하고 이점이 없음.  
- 연산 기호는 고정된 값(+, -, *, /)이기 때문에 제네릭으로 처리할 이유가 없다고 판단하였다.

## 최종 해결 방법
- 최종적으로는 숫자만 제네릭 `<T extends Number>`로 받고, 연산 기호는 단순 char 타입으로 고정하여 사용하였다.

## 배운점
- 제네릭은 타입이 유동적이거나 재사용성이 높을 때 의미가 있다. (ex: `Integer`, `Double` 등 처리).
- 반면, 고정된 값(연산 기호 등)은 오히려 제네릭으로 만들면 복잡해지고 이점이 없다.

